## Transcriptomics Module

This is a place to record notes of coding happenings during the transcriptomics module

# 10/07/2025

On the first day of transcrtipomics we learned about the motivation behind and processes involved in the transciptomics worklow. We discussed applications, what questions can be answered, and critical steps involved in processing RNA. 

We started to run fastp to clean and visualize data quality in our fastq files but encountered some issues with file recognition. To be continued...

# 10/09/2025

Edited our fastp_tonsa.sh to become fastp_tonsa_take2.sh. This script is more fluent in computer speak and lives: 
`/users/s/m/smdecker/projects/eco_genomics_2025/transcriptomics/myscripts`

We ran fastp_tonsa_take2 and produced html files to view quality reports of our samples. 

We made a script called samlon_quant.sh that lives in:

`/users/s/m/smdecker/projects/eco_genomics_2025/transcriptomics/myscripts`

This script will be run next week. 

# 10/14/25
We ran salmon_quant.sh at the end of class since it is computationally significant due to their iterative kmer mapping. Results were placed into: 
`/users/s/m/smdecker/projects/eco_genomics_2025/transcriptomics/myresults`

We are using the VACC emulator (under clusters in UVM on demand)

Using regular expressions (grep -r --include \*.log -e 'Mapping rate') we determined the mapping rate was between 36 and 62% which is very low. Causes could be the new method of low RNA input library prep or the fact that these isopods are of a different clade and thus do not map completetly to the reference. Further, contamination from non-copepod critters (algae, bacteria, etc) could results in RNA that would not map to a copepod reference. 

Mapping rate data was sent with the '>' : 
`grep -r --include \*.log -e 'Mapping rate' > ~/projects/eco_genomics_2025/transcriptomics/myresults/mapping_rate_list.txt`

Or in a classier way via refined reg expressions: 

`grep -r --include \*.log -e 'Mapping rate' > ~/projects/eco_genomics_2025/transcriptomics/myresults/mapping_rate_list.txt`

Broadly we are seeing if the factors of temperature and generation impact the gene expression. 

We created a counts_matrix using an r-script w/ library tximport that lives here: 

`~/projects/eco_genomics_2025/transcriptomics/mydata`

from the script: create_counts_matrix.r: 
'~/projects/eco_genomics_2025/transcriptomics/myscripts'

This will serve as a resource for PCA. We hypothesized that clusters could appear as a function of temperature, generation, and G1 of the treatment group may be further from controls due to its large difference in upper temperature limit until croakation. Replicates within a group should be close to eachother. Treatment gradation from G1-G4 could be evident. Within the control there may be lab acclimation/adaptation signatures. 


# DESeq2 start of data analysis!
We made an Rmarkdown script called 'DESeq2_tonsa_multigen' that lives in: 
`~/projects/eco_genomics_2025/transcriptomics/myscripts`
We copied in metadata.txt to ~/...../mydata and ran the r script

We explored the countsTable (myData) in terms of dimension, histogram of coutns, and other metrics. This all lives in the DESeq2_tonsa_multigen.rmd file 


# 10/17/2025
I missed class thus nothing happened for me today, except a 12 hour driving mission. Package aquired (great-uncle) from boston and delivered to client (great-aunt) in southern VT. 

# 10/21/2025
I am making up for class (10/17) and looking at visualizing the counts matrix in the DESeq2_tonsa_multigen.rmd file 

Additionally, plenty of code was generated later in this same day during class (heatmaps, euler plots, etc)

We made a heatmap according to the below code: 
```{r}
#We made a heatmap according to the below code: 
sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```
We looked for outliers and it appears that some outliers do exist (treatment G2) that appear as heat signatures that are distant from the linear line through the middle of the heatmap. 

A more robust way to identify outliers was done by making a cluster tree according to the code below: 
```{r}
# Lets make a cluster tree to look for outliers 
sampleTree <- hclust(dist(sampleDists), method="average")
# plot
plot(sampleTree, main="Sample clustering to detect outliers", sub="", xlab="",cex.lab=1.5, cex.axis=1.5, cex.main=2)
```
Outliers appear as branches further away from the main clusters.
The outliers seem to be T3R4 and C2R1. This is a really neat way to identfy diverging data points. 

Now its PCA time! 
We constructed PCA plots based on the following code: 
```{r}
# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=line, shape=generation)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```
Clusters appear to be dominated based on generation and experimental condition (control vs. treatment)

We enhanced the aesthetics of the PCA via ggplot using the point geom. Code exists in the DESeq2_tonsa_multigen.rmd script. We then made groups in order to test specific contrasts. 

We then made a script to plot individual genes where individual genes from the above step can be inserted in 'XXXXXX' and plotted one by one. 
```{r}
# Counts of specific top interaction gene! (important validatition that the normalization, model is working)
d <-plotCounts(dds, gene="XXXXXXX", intgroup = (c("line","generation")), returnData=TRUE)
d

p <-ggplot(d, aes(x=line, y=count, color=line, shape=generation)) + 
  theme_minimal() + theme(text = element_text(size=20), panel.grid.major=element_line(colour="grey"))
p <- p + geom_point(position=position_jitter(w=0.2,h=0), size=3)
p <- p + stat_summary(fun = mean, geom = "point", size=5, alpha=0.7) 
p
```

We made an MA plot: 
```{r}
plotMA(resG1_CvT, ylim=c(-5,5))

```
To visualize the most abundance genes we made a heatmap of the top 20: 

```{r}
topgenes <- head(rownames(resG1_CvT),100)
mat <- assay(vsd)[topgenes,]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(dds)[,c("generation","line")])
pheatmap(mat, annotation_col=df)
pheatmap(mat, annotation_col=df, cluster_cols = F)
```
We then made Euler plots to see how generations share or don't share differentually expressed genes. 
These plots are pretty neat, albeit tedious. I wonder what is meant by the 13 differential genes shared by all generations. 

# 10/23/2025
We created a markdown file called 'DESeq2toTopGo.Rmd' that lives in:
`~/projects/eco_genomics_2025/transcriptomics/mydata`
The overarching goal was to understand GO analysis and perform functional enrichment analyses. 

The first code block pulled in the required libs and the counts_matrix.txt file. NOTE: ensure you are reading in with the correct funtion (read.table for .txt file) for the type of data the counts matrix is. The first code block also created a DESeq object (dds). We then grouped by generation. 

The next code chunk (2) was for viewing the distributions of the DESeq run. 

In code chunk 3 we determined the relations between given metrics (Wald Statistic).

Code chunk 4 was used to make a density plot and a rugplot to see what it is we are testing in a GO analysis. 

Chunk 5 is where the party started. First we had to use ondemand clusters to access "Genes_GO_terms_output.tsv" which lived at: 
`/gpfs1/cl/ecogen/pbio6800/Transcriptomics/enrichment`
We then ran TopGO to complete the functional enrichment analysis. 

To see what this all means, we produced GO items in code chunk 6 in order to input GO Ids into Revigo. This allows us to determine the genes which are being enriched, how closely they relate, and produce scatterplots for visualization. 


# 10/28/2025
We started by making a DEPSeq2toWGCNA rmd file that lives:
`~/projects/eco_genomics_2025/transcriptomics/mydata`
The scripts being used are very long, so rather than placing in here I refer my future self to the saved scripts for reference. 

The first step was to filter the DESeq2 data (first code block)

We then used the clusters feature on open on demand to secure copy the file 'WGCNA_TraitData.csv' to:
`~/projects/eco_genomics_2025/transcriptomics/mydata`
This will help our analyses of the phenotypic outcomes of the DGE. 
More precisely, do differential genes correlate to organisms phenotypic outcomes (I think this will be upper critical temperature limit data)

Using the 'WGCNA_TraitData.csv' we imported the trait data and filtered it applying to variance. (Code chunk 2)

We then set soft thresholds based on the filtered data (Code chunk 3)
Interpretting the plot, we want a value greater than 0.8. The degree of connectivity is also important and high values show many genes in few modules, and low means tons of little modues. R-squared above 0.8 with moderate degree of connectivity (not too high not too low). I am choosing 22 for my degree of connectivity. This graph is kinda tough to read. 

Time to build the network! (Code chunk 4) I set my soft power to 22.
The max block size has to be larger than the items in our data. We filtered 50% of 14,000 genes so max block size > 7,000. 
This step takes a little time to run. 

We then made code to plot the dendogram of the modules (Code chunk 5).
My soft power of 22 yielded 18 modules (that was the class average)
The height of the dendogram is the degree of correlation.

Our next mission was to test for the correlation between eigengene and trait data. (Code chunk 6) Pearson's correlation is used here and p-values are pulled out in the code. This makes a heat map of eigengene and trait map data to visualize degree of correlations. An asterix is placed next to significantly correlated eigengenes.

We then focused on the individual model that contains the most correlation to see which genes were present and to which experimental condition they derived. (Code chunk 7) We ggplotted the highly correleated module of genes by generation and condition to see how things are shifting in the gene expression w.r.t gene expression.This yielded the following GO ids: 

GO:0016746
GO:0005634
GO:0000276
GO:0015078
GO:0015986

These can be investigated to understand what they do! Insert into Revigo. 

# Homework Notes 

## General goal

### Produce visualizations and understand the differential gene expression enrichment between generations. The DEGs plotted are the contrast between control and treatment. 

### Pick up post-DESeq2 and run TopGO for each generation (we just did gen2 in class)

### Filter the top 5 most statistically significant GoIDs from TopGO and input to REViGO 

### Take time to understand the molecular significance of the enriched genes and draw speculative hypotheses 

## Bioinformatics Pipeline: 

### Starting point is running DESeq2toTopGO.Rmd in order to initiate variables required for running GO-enrichment 

### A new markdown script was created to analyze the GO-enrichment for all generations names DESeq2_to_TopGO_HW2.Rmd and it lives in: 
`/gpfs1/home/s/m/smdecker/projects/eco_genomics_2025/transcriptomics/mydocs`

### The script serves as a space to run TopGO for each generation (4 code chunks) without overwriting between generations. 

### Each generation is mapped via a bubble plot that reveals the abundance by size of circle

## Yielding GO IDs

### After plotting, the script made in DESeq2toTopGO was used to create a list of GO IDs: 

```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")]

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```

### This script was replicated and modified 4 times to produce GO IDs for each generation and not write over eachother 

### To reduce complexity and make it possible to analyze biological function behind GO terms, the above dataframes (i.e. sigRes1) were filtered (using the toggle option on top of the column) by lowest p-value.

### In excel the GO ids of the 5 lowest p-values were tabulated to input into REVIGO. 

### REVIGO scatter plots of each generation were made. 

### This concludes the bioinformatics pipeline for Homework 2. 








